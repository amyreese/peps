PEP: 9999
Title: Callable Modules
Author: Amethyst Reese <amethyst at n7.gg>
Sponsor: ≈Åukasz Langa <lukasz at python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 20-04-2023
Python-Version: 3.12


Abstract
========

Modules are currently not directly callable. Classes can define a ``__call__``
method that makes instance objects callable, but defining a similarly named
function in the global module scope has no effect, and that function can
only be called by importing or referencing it directly as ``module.__call__``.
:pep:`562` added support for ``__getattr__`` and ``__dir__`` for modules, but
defining ``__getattr__`` to return a value for ``__call__`` still does not
make a module callable.

This PEP proposes support for a ``__call__`` function defined on modules
to make the module object itself callable.


Motivation
==========

Many modules have only a single primary interface to its functionality.
In many cases, that interface is a single callable object, where being able
to use a simple import and using the module as a callable provides a more
"pythonic" interface for users:

.. code-block:: python

    # user.py

    import fancy

    @fancy
    def func(...):
        ...

Currently, providing this style of interface requires modifying the module
object at runtime to make it callable.

This is commonly done by replacing the module object in ``sys.modules`` with
a callable alternative (such as a function or class instance):

.. code-block:: python

    # fancy.py

    def fancy(...):
        ...

    sys.modules[__name__] = fancy

This has the effect of making the original module effectively unreachable
without further hooks from the author, even with ``from module import member``.
It also results in a "module" object that is missing all of the special module
attributes, including ``__doc__``, ``__package__``, ``__path__``, etc.

Alteratively, a module author can choose to override the module's ``__class__``
property with a custom type that provides a callable interface:

.. code-block:: python

    # fancy.py

    def fancy(...):
        ...

    class FancyModule(types.ModuleType):
        def __call__(self, ...):
            return fancy(...)

    sys.modules[__name__].__class__ = FancyModule

The downside of either approach is that it not only results in extra
boilerplate, but also results in type checker failures because they don't
recognize that the module is callable at runtime:

.. code-block:: console

    $ mypy user.py
    user.py:3: error: Module not callable  [operator]
    Found 1 error in 1 file (checked 1 source file)


Specification
=============

When a module object is called, and a ``__call__`` function is found (either
as the result of a ``__getattr__`` or ``__dict__`` lookup), then that function
will be called with the given arguments.

If a ``__call__`` object is not found, then a ``TypeError`` will be raised,
matching the existing behavior.

All of these examples would be considered valid, callable modules:

.. code-block:: python

    # hello.py

    def __call__(...):
        pass

.. code-block:: python

    # hello.py

    class Hello:
        pass

    __call__ = Hello

.. code-block:: python

    # hello.py

    def hello():
        pass

    def __getattr__(name):
        if name == "__call__":
            return hello

The first two styles should generally be preferred, as it allows for easier
static analysis from tools like type checkers, though the third form would be
allowed in order to make the implementation more consistent.


Backwards compatibility and impact on performance
=================================================

This PEP is not expected to cause any backwards incompatibility. Any modules
that already contain a ``__call__`` member will continue to function the same
as before, though with the additional ability to be called directly. It is
considered unlikely that modules with an existing ``__call__`` member would
depend on the existing behavior of raising ``TypeError`` when called.

Performance implications of this PEP are minimal, as it defines a new interface.
Calling a module would trigger a lookup for the name ``__call__`` on a module
object. Existing workarounds for creating callable modules already depend on
this behavior for generic objects, resulting in similar performance for these
callable modules.

Type checkers will likely need to be updated accordingly to treat modules with
a ``__call__`` function as callable. This should be possible to support in type
checkers when checking code targeted at older Python versions that do not
support callable modules, with the expectation that these modules would also
include one of the workarounds mentioned earlier to make the module callable.


Rejected Ideas
==============

Given the introduction of ``__getattr__`` and ``__dir__``, and the proposal
to enable use of ``__call__``, it was considered if it was worth allowing use
of *all* special methods [1]_ for modules, such as ``__or__`` and ``__iter__``.
While this would not be completely undesired, it increases the potential for
backward compatibility concerns, and these other special methods are likely
to provide less utility to library authors in comparison to ``__call__``.


References
==========

.. [1] Data model, special methods
   (https://docs.python.org/3/reference/datamodel.html#special-method-names)


Copyright
=========

This document has been placed in the public domain.

